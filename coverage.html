
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>command: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/goseventh/rakstar/command/argHandler.go (0.0%)</option>
				
				<option value="file1">github.com/goseventh/rakstar/command/boot.go (0.0%)</option>
				
				<option value="file2">github.com/goseventh/rakstar/command/builder.go (69.2%)</option>
				
				<option value="file3">github.com/goseventh/rakstar/command/command.go (85.7%)</option>
				
				<option value="file4">github.com/goseventh/rakstar/command/conditionals.go (78.9%)</option>
				
				<option value="file5">github.com/goseventh/rakstar/command/create.go (100.0%)</option>
				
				<option value="file6">github.com/goseventh/rakstar/command/handlers.go (59.4%)</option>
				
				<option value="file7">github.com/goseventh/rakstar/command/interceptor.go (0.0%)</option>
				
				<option value="file8">github.com/goseventh/rakstar/command/typeNumber.go (90.9%)</option>
				
				<option value="file9">github.com/goseventh/rakstar/command/typePlayer.go (40.0%)</option>
				
				<option value="file10">github.com/goseventh/rakstar/command/typeText.go (100.0%)</option>
				
				<option value="file11">github.com/goseventh/rakstar/vehicles/builder.go (81.8%)</option>
				
				<option value="file12">github.com/goseventh/rakstar/vehicles/clock.go (0.0%)</option>
				
				<option value="file13">github.com/goseventh/rakstar/vehicles/eletrics.go (16.7%)</option>
				
				<option value="file14">github.com/goseventh/rakstar/vehicles/engine.go (51.1%)</option>
				
				<option value="file15">github.com/goseventh/rakstar/vehicles/vehicle.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package command

import (
        "strconv"
)

func (self *ArgHandler) Next(defaultValues ...string) *string <span class="cov0" title="0">{
        var defaultValue *string = nil

        if len(defaultValues) &gt; 0 </span><span class="cov0" title="0">{
                defaultValue = &amp;defaultValues[0]
        }</span>

        <span class="cov0" title="0">if self.currentArg == len(self.args) </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">if self.currentArg == len(self.args) </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">arg := self.args[self.currentArg]
        self.currentArg++

        return &amp;arg</span>
}

func (self *ArgHandler) NextInt(defaultValues ...int) *int <span class="cov0" title="0">{
        var defaultValue *int = nil

        if len(defaultValues) &gt; 0 </span><span class="cov0" title="0">{
                defaultValue = &amp;defaultValues[0]
        }</span>

        <span class="cov0" title="0">nextValue := self.Next()

        if nextValue == nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">converted, err := strconv.ParseInt(*nextValue, 0, 64)

        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">asInt := int(converted)

        return &amp;asInt</span>
}

func (self *ArgHandler) NextFloat(defaultValues ...float64) *float64 <span class="cov0" title="0">{
        var defaultValue *float64 = nil

        if len(defaultValues) &gt; 0 </span><span class="cov0" title="0">{
                defaultValue = &amp;defaultValues[0]
        }</span>

        <span class="cov0" title="0">nextValue := self.Next()

        if nextValue == nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">converted, err := strconv.ParseFloat(*nextValue, 0)

        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">asFloat64 := float64(converted)

        return &amp;asFloat64</span>
}

func (self *ArgHandler) Restore() <span class="cov0" title="0">{
        self.currentArg = 0
}</span>

func (self *ArgHandler) GetInput() *string <span class="cov0" title="0">{
        return &amp;self.input
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package command

import (
        "github.com/goseventh/rakstar/chat"
        "github.com/goseventh/rakstar/internal/callbacks"
        "github.com/goseventh/rakstar/internal/utils/common"
)

/*
Função que é chamada pelo inicializador do RakStar
*/
func Boot() bool <span class="cov0" title="0">{
        chat := chat.Builder()
        chat.Color(common.WarnColorStr).
                Message("Nenhum comando foi encontrado")
        SetConfig(chat, "Comando errado, similar")

        err := callbacks.On("playerCommandText", HandlePlayerCommandText)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package command

import (
        "time"
)

type commandBuilder struct {
<<<<<<< HEAD
        cmd          string
        alias        []string
        handler      CommandHandler
        conditionals map[int][]condition
=======
        cmd                 string
        alias               []string
        handler             CommandHandler
        conditionals        map[int][]condition
        conditionalsBuilder *conditionalsBuilder
>>>>>>> dev
}

type ArgHandler struct {
        input      string
        args       []string
        currentArg int
}

func Builder() *commandBuilder <span class="cov8" title="1">{
        c := new(commandBuilder)
        c.conditionals = make(map[int][]condition)
        return c
}</span>

func (c *commandBuilder) Wait(wait ...time.Duration) *commandBuilder <span class="cov0" title="0">{
        if wait[0] &lt; time.Second </span><span class="cov0" title="0">{
                wait[0] = time.Second
        }</span>
        <span class="cov0" title="0">time.Sleep(wait[0])

        return c</span>
}

<<<<<<< HEAD
func (c *commandBuilder) Conditionals() *conditionalsBuilder <span class="cov0" title="0">{
        condit := new(conditionalsBuilder)
        //condit.conditionals_ = make(map[int][]int)
        condit.c = c

        return condit
}</span>
=======
func (c *commandBuilder) Conditionals() *conditionalsBuilder <span class="cov8" title="1">{
        if c.conditionalsBuilder != nil </span><span class="cov8" title="1">{
                return c.conditionalsBuilder
        }</span>

        <span class="cov8" title="1">condit := new(conditionalsBuilder)
        condit.c = c
        c.conditionalsBuilder = condit
        return condit</span>
}
>>>>>>> dev
</pre>
		
		<pre class="file" id="file3" style="display: none">package command

import (
        "reflect"
        "strings"

        "github.com/agnivade/levenshtein"
        "github.com/goseventh/rakstar/internal/natives"
)

type CommandHandler func(context *CommandContext)

type Command struct {
        Name          string
<<<<<<< HEAD
=======
  conditions map[int][]condition
>>>>>>> dev
        Handler       CommandHandler
        Interceptors  []CommandInterceptorHandler
        Description   string
        RequireLogin  bool
        Aliases       []string
        Roles         []string
<<<<<<< HEAD
        conditionals_ map[int][]condition
=======
>>>>>>> dev
}

type CommandContext struct {
        Player     *natives.Player
        ArgHandler *ArgHandler
}

var commands = make(map[string]*Command)

func (self *CommandInterceptorContext) Next() <span class="cov0" title="0">{
        self.next = true
}</span>

func RegisterCommand(command *Command) (bool, error) <span class="cov8" title="1">{
        commandToRegist := commands[strings.ToLower(command.Name)]

        if commandToRegist != nil </span><span class="cov0" title="0">{
                command.Interceptors = commandToRegist.Interceptors
                commandToRegist = command
        }</span>

        <span class="cov8" title="1">if commandToRegist == nil </span><span class="cov8" title="1">{
                commandToRegist = command
        }</span>

        <span class="cov8" title="1">commands[strings.ToLower(command.Name)] = commandToRegist

        for _, name := range commandToRegist.Aliases </span><span class="cov8" title="1">{
                commands[strings.ToLower(name)] = commandToRegist
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func SearchCommand(inputName string) (*Command, int) <span class="cov8" title="1">{
        inputName = strings.ToLower(inputName)

        commandsKeys := reflect.ValueOf(commands).MapKeys()

        var lastCommand *Command = nil
        var lastDistance = -1

        for _, commandName := range commandsKeys </span><span class="cov8" title="1">{
                command := commands[commandName.String()]

                if command.Handler == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">distance := levenshtein.ComputeDistance(commandName.String(), inputName)

                if lastCommand == nil || lastDistance == -1 || distance &lt; lastDistance </span><span class="cov8" title="1">{

                        lastDistance = distance
                        lastCommand = command

                        if distance == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if lastDistance == -1 || lastDistance &gt; 2 </span><span class="cov8" title="1">{
                return nil, lastDistance
        }</span>

        <span class="cov8" title="1">return lastCommand, lastDistance</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package command

const (
<<<<<<< HEAD
        typePlayer = iota
=======
        undefined = iota
        typePlayer
>>>>>>> dev
        typeNumber
        typeText
)

type conditionalsBuilder struct {
<<<<<<< HEAD
        index   int
        typeIdx int
        conditions []condition
        c      *commandBuilder
=======
        index      int
        typeIdx    int
        conditions []condition
        c          *commandBuilder
>>>>>>> dev
}

type condition struct {
        typeIdx int
        cond    int
        value   interface{}
}

<<<<<<< HEAD
func (c *conditionalsBuilder) Index(index int) *conditionalsBuilder <span class="cov0" title="0">{
        c.index = index
        return c
}</span>

// registra as condicionais para cada indice(index)
func (c *conditionalsBuilder) Set() *conditionalsBuilder <span class="cov0" title="0">{

=======
func (c *conditionalsBuilder) Index(index int) *conditionalsBuilder <span class="cov8" title="1">{
        if index &lt; 0 </span><span class="cov8" title="1">{
                index = 0
        }</span>
        <span class="cov8" title="1">c.index = index
        return c</span>
}

func (c *conditionalsBuilder) createConditional(typeCond, typeIdx int, value interface{}) <span class="cov8" title="1">{
        cond := condition{
                cond:    typeCond,
                typeIdx: typeIdx,
                value:   value,
        }

        c.conditions = append(c.conditions, cond)
}</span>

// registra as condicionais para cada indice(index)
func (c *conditionalsBuilder) Set() *conditionalsBuilder <span class="cov8" title="1">{
>>>>>>> dev
        if c.index &lt; 0 </span><span class="cov0" title="0">{
                return c
        }</span>

<<<<<<< HEAD
        <span class="cov0" title="0">if c.conditions == nil || len(c.conditions) == 0 </span><span class="cov0" title="0">{
                return c
        }</span>
  
        <span class="cov0" title="0">c.c.conditionals[c.index] = c.conditions
=======
        <span class="cov8" title="1">if c.conditions == nil || len(c.conditions) == 0 </span><span class="cov0" title="0">{
                return c
        }</span>

        <span class="cov8" title="1">c.c.conditionals[c.index] = c.conditions
>>>>>>> dev
        c.conditions = nil
        return c</span>
}

func (t *TypePlayer) EndConditionals() *commandBuilder <span class="cov0" title="0">{
        t.End()
        return t.c.c
}</span>
<<<<<<< HEAD
=======

func (t *TypeNumber) EndConditionals() *commandBuilder <span class="cov8" title="1">{
        t.End()
        return t.c.c
}</span>

func (t *TypeText) EndConditionals() *commandBuilder <span class="cov8" title="1">{
        t.End()
        return t.c.c
}</span>
>>>>>>> dev
</pre>
		
		<pre class="file" id="file5" style="display: none">package command

<<<<<<< HEAD

=======
>>>>>>> dev
func (cb *commandBuilder) Command(cmd string) *commandBuilder <span class="cov8" title="1">{
        cb.cmd = cmd
        return cb
}</span>

func (cb *commandBuilder) Alias(cmd string) *commandBuilder <span class="cov8" title="1">{
        cb.alias = append(cb.alias, cmd)
        return cb
}</span>

func (cb *commandBuilder) Handler(handler CommandHandler) *commandBuilder <span class="cov8" title="1">{
        cb.handler = handler
        return cb
}</span>

func (cb *commandBuilder) Create() <span class="cov8" title="1">{
<<<<<<< HEAD
        
        cmd := &amp;Command{
                Name:    cb.cmd,
                Aliases: cb.alias,
                Handler: cb.handler,
                conditionals_: cb.conditionals,
        }

        RegisterCommand(cmd)

=======
        cmd := &amp;Command{
                Name:       cb.cmd,
                Aliases:    cb.alias,
                Handler:    cb.handler,
                conditions: cb.conditionals,
        }

        RegisterCommand(cmd)
>>>>>>> dev
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package command

import (
        "fmt"
        "log"
<<<<<<< HEAD
        "strconv"

        //"main/pkg/server"
        //        "main/pkg/utils/sampstr"
=======
        "regexp"
        "strconv"
>>>>>>> dev
        "strings"

        "github.com/goseventh/rakstar/chat"
        "github.com/goseventh/rakstar/internal/natives"
        "github.com/goseventh/rakstar/internal/utils/common"
        "github.com/goseventh/rakstar/internal/utils/constants/playerConst"
        "github.com/goseventh/rakstar/internal/utils/sampstr"
        "github.com/goseventh/rakstar/server"
)

var NotFoundChat *chat.ChatBuilder
var SimiularFoundMSG *string

type rawCommand struct {
        name string
        args []string
}

/*
seta as mensagens que são executadas qunado um comando similar é encontrado, ou quando nenhum é encontrado.

# Exemplo:

cb := chat.builder()

cb.Message("nenhum comando encontrado")

similarFound := "comando similar"

SetConfig(cb, similarFound)

# # Resultado:

  - *Jogador digita "/command", mas não existe:

    &gt; chat: nenhum comando foi encontrado

  - *Jogador digita "/aujad", e similar foi encontrado: "ajuda"

    &gt; chat: comando similar: ajuda
*/
func SetConfig(notFoundChat *chat.ChatBuilder, similarFoundMsg string) <span class="cov0" title="0">{
        NotFoundChat = notFoundChat
        SimiularFoundMSG = &amp;similarFoundMsg
}</span>

/*
Função que deve ser chamada na callback "OnPlayerCommand"
*/
func HandlePlayerCommandText(player natives.Player, cmdtext string) bool <span class="cov0" title="0">{
        server.Builder().
                Goroutine().
                Submit(func() </span><span class="cov0" title="0">{
                        processCommand(player, cmdtext)
                }</span>)

        <span class="cov0" title="0">return true</span>
}

func parseCommandArgs(cmdtext string) rawCommand <span class="cov8" title="1">{
        splitCmdText := strings.Split(sampstr.Decode(cmdtext), " ")

        name := strings.Replace(splitCmdText[0], "/", "", -1)
        args := splitCmdText[1:]

        return rawCommand{
                name,
                args,
        }
}</span>

func parseArgHandler(args []string) ArgHandler <span class="cov8" title="1">{
        var argHandler = ArgHandler{}

        if len(args) &gt;= 1 </span><span class="cov8" title="1">{
                argHandler.args = args
                argHandler.input = strings.Join(args, " ")
                argHandler.currentArg = 0
        }</span>

        <span class="cov8" title="1">return argHandler</span>
}

<<<<<<< HEAD
func validateArgs(command *Command, args []string) bool <span class="cov0" title="0">{
        if len(command.conditionals_) &gt; 0 &amp;&amp; len(args) &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for idx, arg := range args </span><span class="cov0" title="0">{
                for _, cond := range command.conditionals_[idx] </span><span class="cov0" title="0">{
                        switch cond.typeIdx </span>{
                        case typePlayer:<span class="cov0" title="0">
                                var id int = -1
                                var err error
                                id, err = strconv.Atoi(arg)
                                if err != nil </span><span class="cov0" title="0">{
                                        var nick string
                                        for i := 0; i &lt; playerConst.MaxPlayers; i++ </span><span class="cov0" title="0">{
                                                natives.GetPlayerName(i, &amp;nick, playerConst.MaxPlayerName)
                                                if nick == arg </span><span class="cov0" title="0">{
                                                        id = i
                                                        break</span>
                                                }
                                        }
                                }

                                <span class="cov0" title="0">switch cond.cond </span>{
                                case MustPlayerConnected:<span class="cov0" title="0">
                                        if !natives.IsPlayerConnected(id) </span><span class="cov0" title="0">{
                                                log.Printf("[rakstar-cmd idx(%v)] o jogador %v não está conectado", idx, id)
                                                return false
                                        }</span>

                                case MustNickIs:<span class="cov0" title="0">
                                        var nick string
                                        natives.GetPlayerName(id, &amp;nick, playerConst.MaxPlayerName)
                                        if cond.value != nick </span><span class="cov0" title="0">{
                                                log.Printf("[rakstar-cmd idx(%v)] falha na comparação de nicks entre %v:%v", idx, nick, cond.value)
                                                return false
                                        }</span>
                                }
                        }

                }
        }

        <span class="cov0" title="0">return true</span>
}

func processCommand(player natives.Player, cmdtext string) bool <span class="cov0" title="0">{
=======
func getIDfromName(nick string) int <span class="cov0" title="0">{
        var id int = -1
        var err error
        id, err = strconv.Atoi(nick)
        if err != nil </span><span class="cov0" title="0">{
                var nickSearch string
                for i := 0; i &lt; playerConst.MaxPlayers; i++ </span><span class="cov0" title="0">{
                        natives.GetPlayerName(i, &amp;nickSearch, playerConst.MaxPlayerName)
                        if compareNicks(nickSearch, nick) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return id</span>
}

func compareNicks(nick, nick2 string) bool <span class="cov0" title="0">{
        return nick == nick2
}</span>

func getNickFromID(id int) string <span class="cov0" title="0">{
        nick := ""
        natives.GetPlayerName(id, &amp;nick, playerConst.MaxPlayerName)
        return nick
}</span>

func isConnected(id int) bool <span class="cov0" title="0">{
        return natives.IsPlayerConnected(id)
}</span>

func verifyTypePlayer(cond condition, idx int, arg string) bool <span class="cov0" title="0">{
        id := getIDfromName(arg)
        switch cond.cond </span>{
        case MustPlayerConnected:<span class="cov0" title="0">
                if !isConnected(id) </span><span class="cov0" title="0">{
                        log.Printf("[rakstar-cmd idx(%v)] o jogador %v não está conectado", idx, id)
                        return false
                }</span>

        case MustNickIs:<span class="cov0" title="0">
                nick := getNickFromID(id)
                if !compareNicks(nick, cond.value.(string)) </span><span class="cov0" title="0">{
                        log.Printf("[rakstar-cmd idx(%v)] falha na comparação de nicks entre %v:%v",
                                idx, nick, cond.value)
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func valueStrBeBetween(xStr string, lessGreater []int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len(lessGreater) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len(lessGreater) &gt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x &lt; lessGreater[0] &amp;&amp; x &gt; lessGreater[1]</span>
}

func valueStrBeGreeter(xStr string, y int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x &gt; y</span>
}

func valueStrBeLess(xStr string, y int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x &lt; y</span>
}

func valueStrEqual(xStr string, y int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x == y</span>
}

func valueStrDivisibleBy(xStr string, y int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x%y == 0</span>
}

func valueStrSquareRootOf(xStr string, y int) bool <span class="cov8" title="1">{
        x, err := strconv.Atoi(xStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return x*x == y</span>
}

func verifyTypeNumber(cond condition, idx int, arg string) bool <span class="cov8" title="1">{
        switch cond.cond </span>{
        case MustBeBetween:<span class="cov0" title="0">
                if !valueStrBeBetween(arg, cond.value.([]int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case MustBeGreaterThan:<span class="cov0" title="0">
                if !valueStrBeGreeter(arg, cond.value.(int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case MustBeLessThan:<span class="cov0" title="0">
                if !valueStrBeLess(arg, cond.value.(int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case MustEqual:<span class="cov8" title="1">
                if !valueStrEqual(arg, cond.value.(int)) </span><span class="cov8" title="1">{
                        return false
                }</span>
        case MustBeDivisibleBy:<span class="cov0" title="0">
                if !valueStrDivisibleBy(arg, cond.value.(int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case MustBeMultipleOf:<span class="cov0" title="0">
                if !valueStrDivisibleBy(arg, cond.value.(int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case MustBeSquareRootOf:<span class="cov8" title="1">
                if !valueStrSquareRootOf(arg, cond.value.(int)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func textIsUpper(text string) bool <span class="cov8" title="1">{
        return text == strings.ToUpper(text)
}</span>

func textIsLower(text string) bool <span class="cov8" title="1">{
        return text == strings.ToLower(text)
}</span>

func textIsPrefix(text, prefix string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(text, prefix)
}</span>

func textIsSuffix(text, prefix string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(text, prefix)
}</span>

func textIsRegMatch(text, regex string) bool <span class="cov8" title="1">{
        ok, err := regexp.Match(regex, []byte(text))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return ok</span>
}

func verifyTypeText(cond condition, idx int, arg string) bool <span class="cov8" title="1">{
        switch cond.cond </span>{
        case MustBeUppercase:<span class="cov8" title="1">
                if !textIsUpper(arg) </span><span class="cov8" title="1">{
                        return false
                }</span>
        case MustBeLowercase:<span class="cov8" title="1">
                if !textIsLower(arg) </span><span class="cov8" title="1">{
                        return false
                }</span>
        case MustHavePrefix:<span class="cov8" title="1">
                if !textIsPrefix(arg, cond.value.(string)) </span><span class="cov8" title="1">{
                        return false
                }</span>
        case MustHaveSufix:<span class="cov8" title="1">
                if !textIsSuffix(arg, cond.value.(string)) </span><span class="cov8" title="1">{
                        return false
                }</span>
        case MustCompileRegex:<span class="cov8" title="1">
                if !textIsRegMatch(arg, cond.value.(string)) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func validateConditions(command *Command, idx int, arg string) bool <span class="cov8" title="1">{
        var status bool = true
        for _, cond := range command.conditions[idx] </span><span class="cov8" title="1">{
                switch cond.typeIdx </span>{
                case typePlayer:<span class="cov0" title="0">
                        ok := verifyTypePlayer(cond, idx, arg)
                        log.Printf("[validateConditions] typePlayer is valid? %v", ok)
                        if !ok </span><span class="cov0" title="0">{
        status = false
                                // return false
                        }</span>
                case typeNumber:<span class="cov8" title="1">
                        ok := verifyTypeNumber(cond, idx, arg)
                        log.Printf("[validateConditions] typeNumber is valid? %v", ok)
                        if !ok </span><span class="cov8" title="1">{
        status = false
                                // return false
                        }</span>
                case typeText:<span class="cov8" title="1">
                        ok := verifyTypeText(cond, idx, arg)
                        log.Printf("[validateConditions] typeText is valid? %v", ok)
                        if !ok </span><span class="cov8" title="1">{
                                status = false
                                // return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return status</span>
}

func validateArgs(command *Command, args []string) bool <span class="cov8" title="1">{
        if len(command.conditions) &gt; 0 &amp;&amp; len(args) &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for idx, arg := range args </span><span class="cov8" title="1">{
                ok := validateConditions(command, idx, arg)
                log.Printf("[validateArgs] validateConditions is valid? - %v", ok)
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func processCommand(player natives.Player, cmdtext string) bool <span class="cov8" title="1">{
>>>>>>> dev
        rawCommand := parseCommandArgs(cmdtext)
        command, distance := SearchCommand(rawCommand.name)

        if command == nil </span><span class="cov0" title="0">{
                NotFoundChat.
                        Select(player.ID).
                        Tag("rakstar").
                        Send()

                return false
        }</span>

<<<<<<< HEAD
        <span class="cov0" title="0">if distance &gt;= 1 &amp;&amp; distance &lt;= 2 </span><span class="cov0" title="0">{
=======
        <span class="cov8" title="1">if distance &gt;= 1 &amp;&amp; distance &lt;= 2 </span><span class="cov0" title="0">{
>>>>>>> dev
                chat.Builder().
                        Select(player.ID).
                        Color(common.WarnColorStr).
                        Tag("rakstar").
                        Message(fmt.
                                Sprintf(
                                        "%v: %v",
                                        *SimiularFoundMSG,
                                        command.Name,
                                )).
                        Send()
        }</span>

<<<<<<< HEAD
        <span class="cov0" title="0">argHandler := parseArgHandler(rawCommand.args)
=======
        <span class="cov8" title="1">argHandler := parseArgHandler(rawCommand.args)
>>>>>>> dev

        context := CommandContext{
                Player:     &amp;player,
                ArgHandler: &amp;argHandler,
        }

        isValidArgs := validateArgs(command, rawCommand.args)

<<<<<<< HEAD
        if !isValidArgs </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">log.Printf("[rakstar] running command [%s] for player %s\n", command.Name, player.GetName())

        command.Handler(&amp;context)
=======
        log.Printf("[processCommand] args is valid? - %v", isValidArgs)
        if !isValidArgs </span><span class="cov8" title="1">{
                return false
        }</span>

        // log.Printf("[rakstar] running command [%s] for player %s\n", command.Name, player.GetName())

        <span class="cov8" title="1">command.Handler(&amp;context)
>>>>>>> dev

        return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package command

import (
        "strings"

        "github.com/goseventh/rakstar/internal/natives"
)

type CommandInterceptorContext struct {
        Player     *natives.Player
        ArgHandler *ArgHandler
        next       bool
}

type CommandInterceptorHandler func(context *CommandInterceptorContext)

func RegisterInterceptor(commandName string, interceptor CommandInterceptorHandler) <span class="cov0" title="0">{
        command := commands[strings.ToLower(commandName)]

        if command == nil </span><span class="cov0" title="0">{
                command = &amp;Command{
                        Name:         commandName,
                        Interceptors: []CommandInterceptorHandler{interceptor},
                }

                commands[strings.ToLower(commandName)] = command

                return
        }</span>

        <span class="cov0" title="0">command.Interceptors = append(command.Interceptors, interceptor)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package command

const (
<<<<<<< HEAD
=======
        MustEqual = iota
        MustBeDivisibleBy
        MustBeGreaterThan
        MustBeLessThan
        MustBeBetween
        MustBeMultipleOf
        MustBeSquareRootOf
)

type TypeNumber struct {
        c *conditionalsBuilder
}

func (c *conditionalsBuilder) TypeNumber() *TypeNumber <span class="cov8" title="1">{
        c.typeIdx = typeNumber
        tNumber := new(TypeNumber)
        tNumber.c = c
        return tNumber
}</span>

func (t *TypeNumber) MustEqual(x int) *TypeNumber <span class="cov8" title="1">{
        t.c.createConditional(MustEqual, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeDivisibleBy(x int) *TypeNumber <span class="cov0" title="0">{
        t.c.createConditional(MustBeDivisibleBy, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeGreaterThan(x int) *TypeNumber <span class="cov8" title="1">{
        t.c.createConditional(MustBeGreaterThan, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeLessThan(x int) *TypeNumber <span class="cov8" title="1">{
        t.c.createConditional(MustBeLessThan, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeMultipleOf(x int) *TypeNumber <span class="cov8" title="1">{
        t.c.createConditional(MustBeMultipleOf, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeSquareRootOf(x int) *TypeNumber <span class="cov8" title="1">{
        t.c.createConditional(MustBeSquareRootOf, t.c.typeIdx, x)
        return t
}</span>

func (t *TypeNumber) MustBeBetween(min, max int) *TypeNumber <span class="cov8" title="1">{
        var values []int
        values = (append(values, min, max))
        t.c.createConditional(MustBeBetween, t.c.typeIdx, values)
        return t
}</span>

func (t *TypeNumber) End() *conditionalsBuilder <span class="cov8" title="1">{
        t.c.Set()
        return t.c
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package command

const (
>>>>>>> dev
        MustPlayerConnected = iota
        MustNickIs
)

type TypePlayer struct {
        c *conditionalsBuilder
}

<<<<<<< HEAD
func (c *conditionalsBuilder) TypePlayer() *TypePlayer <span class="cov0" title="0">{
        c.typeIdx = typePlayer
        tPlayer := new(TypePlayer)
        tPlayer.c = c

=======
func (c *conditionalsBuilder) TypePlayer() *TypePlayer <span class="cov8" title="1">{
        c.typeIdx = typePlayer
        tPlayer := new(TypePlayer)
        tPlayer.c = c
>>>>>>> dev
        return tPlayer
}</span>

func (t *TypePlayer) MustConnected() *TypePlayer <span class="cov0" title="0">{
<<<<<<< HEAD
        cond := condition{
                cond:    MustPlayerConnected,
                typeIdx: t.c.index,
        }

        t.c.conditions = append(t.c.conditions, cond)
=======
        t.c.createConditional(MustPlayerConnected, t.c.typeIdx, nil)
>>>>>>> dev
        return t
}</span>

func (t *TypePlayer) MustNickIs(nick string) *TypePlayer <span class="cov0" title="0">{
<<<<<<< HEAD
        cond := condition{
                cond:    MustNickIs,
                typeIdx: t.c.index,
                value:   nick,
        }

        t.c.conditions = append(t.c.conditions, cond)
=======
        t.c.createConditional(MustNickIs, t.c.typeIdx, nick)
>>>>>>> dev
        return t
}</span>

func (t *TypePlayer) End() *conditionalsBuilder <span class="cov0" title="0">{
        t.c.Set()
        return t.c
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file9" style="display: none">/*
=======
		<pre class="file" id="file10" style="display: none">package command

const (
        MustBeUppercase = iota
        MustBeLowercase
        MustHavePrefix
        MustHaveSufix
        MustCompileRegex
)

type TypeText struct {
        c *conditionalsBuilder
}

func (c *conditionalsBuilder) TypeText() *TypeText <span class="cov8" title="1">{
        c.typeIdx = typeText
        tText := new(TypeText)
        tText.c = c
        return tText
}</span>

func (t *TypeText) MustBeUppercase() *TypeText <span class="cov8" title="1">{
        t.c.createConditional(MustBeUppercase, t.c.typeIdx, nil)
        return t
}</span>

func (t *TypeText) MustBeLowercase() *TypeText <span class="cov8" title="1">{
        t.c.createConditional(MustBeLowercase, t.c.typeIdx, nil)
        return t
}</span>

func (t *TypeText) MustHavePrefix(preffix string) *TypeText <span class="cov8" title="1">{
        t.c.createConditional(MustHavePrefix, t.c.typeIdx, preffix)
        return t
}</span>

func (t *TypeText) MustHaveSufix(sufix string) *TypeText <span class="cov8" title="1">{
        t.c.createConditional(MustHaveSufix, t.c.typeIdx, sufix)
        return t
}</span>

func (t *TypeText) MustCompileRegex(regex string) *TypeText <span class="cov8" title="1">{
        t.c.createConditional(MustCompileRegex, t.c.typeIdx, regex)
        return t
}</span>

func (t *TypeText) End() *conditionalsBuilder <span class="cov8" title="1">{
        t.c.Set()
        return t.c
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
>>>>>>> dev
Este pacote oferece o sistema Advanced Vehicle Engine, permitindo
a criação e simulação avançada do comportamento de veículos,
inspirados no mundo real. Com este pacote, os desenvolvedores
têm a capacidade de criar e manipular veículos virtuais com
detalhes minuciosos, incluindo características como o sistema de
combustível, consumo, parte elétrica do veículo, bateria e sistemas
de ignição.
*/
package vehicles

type vehicleBuilder struct {
        id                           int
        model                        int
        health                       float32
        colorPrimary, colorSecondary int
        posX, posY, posZ, rotate     float32
        eletrics                     struct {
                batteryCharger float32
                v              *vehicleBuilder
        }
  engine struct{
    fuel float32
    fuelEconomy float32
  }
}

type eletricsBuilder struct {
        // batteryCharger float32
        v              *vehicleBuilder
}

type engineBuilder struct {
        // fuel        float32
        // fuelEconomy float32
        v           *vehicleBuilder
}
 
func Builder() *vehicleBuilder <span class="cov8" title="1">{
        v := new(vehicleBuilder)
        v.id = -1
        return v
}</span>

/*Funcao par ser funcar*/
func (v *vehicleBuilder) Engine() *engineBuilder <span class="cov8" title="1">{
        e := new(engineBuilder)
        e.v = v
        return e
}</span>

func (v *vehicleBuilder) Eletrics() *eletricsBuilder <span class="cov8" title="1">{
        e := new(eletricsBuilder)
        e.v = v
        return e
}</span>

/*
Seleciona o veículo que será usado para manipulações

- Recebe o ID de criação do veículo
*/
func (v *vehicleBuilder) Select(id int) *vehicleBuilder <span class="cov0" title="0">{
        v.id = id
        return v
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file10" style="display: none">package vehicles
=======
		<pre class="file" id="file12" style="display: none">package vehicles
>>>>>>> dev

import (
        "math/rand"
        "time"

        "github.com/goseventh/rakstar/server"
)

/*
Inicia o clock do veículo
  - O clock do veículo realiza todo o processamento e computação
    necessários para que os sistemas elétricos, motor, e outros
    funcionem corretamente.

Importante: invocar mais de uma vez essa função na mesma instância, causará
comportamentos estranhos
*/
func (v *vehicleBuilder) Start() *vehicleBuilder <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Second)
        server.Builder().
                Goroutine().Submit(
                func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                &lt;-ticker.C
        v.Eletrics().IntroduceElectricalDrain()
                                // verifyBattery(v)
                                // verifyFuel(v)
                                v.engine.fuel -= (0.001 - v.engine.fuelEconomy)
                                v.eletrics.batteryCharger -= 0.001
                        }</span>

                },
        )
        <span class="cov0" title="0">return v</span>
}

func verifyFuel(v *vehicleBuilder) <span class="cov0" title="0">{
        if v.engine.fuel &gt; 25 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">state := rand.Intn(1 - (-1) + 1)
        if state != 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">v.Engine().TurnOff()</span>

}
// func verifyBattery(v *vehicleBuilder) {
//         server.
//                 Builder().
//                 Goroutine().Submit(
//                 func() {
//                         var lights int
//                         natives.GetVehicleParamsEx(
//                                 v.id,
//                                 nil,
//                                 &amp;lights,
//                                 nil,
//                                 nil,
//                                 nil,
//                                 nil,
//                                 nil,
//                         )
//                         if lights != 1 {
//                                 return
//                         }
//                         if v.eletrics.batteryCharger &gt; 25 {
//                                 return
//                         }
//                         state := rand.Intn(1 - (-1) + 1)
//                         rounds := rand.Intn(100 - (-30) + 100)
//                         if state != 0 {
//                                 return
//                         }
//                         for i := 0; i &lt; rounds; i++ {
//                                 time.Sleep(time.Duration(rand.Intn(1000 - 100 + 1000)))
//                                 v.Eletrics().ToggleLights()
//                         }
//                 })
// }
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file11" style="display: none">package vehicles
=======
		<pre class="file" id="file13" style="display: none">package vehicles
>>>>>>> dev

import "github.com/goseventh/rakstar/internal/natives"
import "math/rand"
import "time"

/*
Alterar a carga da bateria: valores 0~100
*/
func (e *eletricsBuilder) BatteryCharger(charger float32) *eletricsBuilder <span class="cov8" title="1">{
        if charger &gt; 100 </span><span class="cov8" title="1">{
                charger = 100
        }</span> else<span class="cov8" title="1"> if charger &lt; 0 </span><span class="cov0" title="0">{
                charger = 0
        }</span>

        <span class="cov8" title="1">e.v.eletrics.batteryCharger = charger
        return e</span>
}

func (e *eletricsBuilder) GetBatteryCharger() float32 <span class="cov8" title="1">{
        return e.v.eletrics.batteryCharger
}</span>

/*
Altera o estado do faról do veículo

- Se estiver ligado, o faról desligará

- Se estiver desligado, o faról ligará
*/
func (e *eletricsBuilder) ToggleLights() *eletricsBuilder <span class="cov0" title="0">{
        var (
                engine    int
                lights    int
                alarm     int
                doors     int
                bonnet    int
                boot      int
                objective int
        )
        natives.GetVehicleParamsEx(
                e.v.id,
                &amp;engine,
                &amp;lights,
                &amp;alarm,
                &amp;doors,
                &amp;bonnet,
                &amp;boot,
                &amp;objective,
        )
        if lights == 1 </span><span class="cov0" title="0">{
                lights = 0
        }</span> else<span class="cov0" title="0"> if lights == 0 </span><span class="cov0" title="0">{
                lights = 1
        }</span>
        <span class="cov0" title="0">natives.SetVehicleParamsEx(
                e.v.id,
                engine,
                lights,
                alarm,
                doors,
                bonnet,
                boot,
                objective,
        )
        return e</span>
}

// Quando invocada verificará se o veículo tem carga
// suficiente na bateria: &lt;25% acontecerá uma
// pane em todo o sistema elétrico.
// Se tudo ocorrer bem, a função dormirá entre 7-3
// segundos para simular o dreno da bateria.
//
// - Utilize essa função para simular uma ignição
func (e *eletricsBuilder) IntroduceElectricalDrain() <span class="cov0" title="0">{
        vehicleID := e.v.id
        engine := 0
        lights := 0
        alarm := 0
        doors := 0
        bonnet := 0
        boot := 0
        objective := 0

        natives.GetVehicleParamsEx(
                vehicleID,
                &amp;engine,
                &amp;lights,
                &amp;alarm,
                &amp;doors,
                &amp;bonnet,
                &amp;boot,
                &amp;objective,
        )

        if lights != 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if e.v.eletrics.batteryCharger &gt; 25 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">state := rand.Intn(1 - (-1) + 1)
        rounds := rand.Intn(150 - (-30) + 150)
        if state != 0 </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(rand.Intn(7000 - 3000 + 7000)))
                return
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; rounds; i++ </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(rand.Intn(1000 - 100 + 1000)))
                e.v.Eletrics().ToggleLights()
        }</span>
}
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file12" style="display: none">package vehicles
=======
		<pre class="file" id="file14" style="display: none">package vehicles
>>>>>>> dev

import (
        "math"
        "math/rand"
        // "time"

        "github.com/goseventh/rakstar/internal/natives"
)

/*
Altera a economia de combustível do veículo: valores 0~100

- Se definido como 100, provavelmente o veículo não consumirá
quantias significantes e em alguns casos pode-se tornar combustível
infinito. Se definido 0, o veículo consumirá drasticamente e provavelmente,
de forma imediata.
*/
func (e *engineBuilder) FuelEconomy(fe float32) *engineBuilder <span class="cov8" title="1">{
        if fe &gt; 100 </span><span class="cov8" title="1">{
                fe = 100
        }</span> else<span class="cov8" title="1"> if fe &lt; 0 </span><span class="cov0" title="0">{
                fe = 0
        }</span>
        <span class="cov8" title="1">e.v.engine.fuelEconomy = fe
        return e</span>
}

/*
Altera o combustível que o veículo possuí no tanque: valores 0~100

- 100 -&gt; Tanque cheio

- 0 -&gt; Tanque vazio
*/
func (e *engineBuilder) Fuel(f float32) *engineBuilder <span class="cov8" title="1">{
        if f &gt; 100 </span><span class="cov8" title="1">{
                f = 100
        }</span> else<span class="cov8" title="1"> if f &lt; 0 </span><span class="cov0" title="0">{
                f = 0
        }</span>
        <span class="cov8" title="1">e.v.engine.fuel = f
        return e</span>
}

// Retorna a qunatidade de combustível no tanque
//
// 100 = cheio;
// 0 = vazio
func (e *engineBuilder) GetFuel() float32 <span class="cov8" title="1">{
        return e.v.engine.fuel
}</span>

// Retorna a qunatidade de economia de combustível
//
// 100 = economia máxima;
// 0 = economia minima/nenhuma
func (e *engineBuilder) GetFuelEconomy() float32 <span class="cov8" title="1">{
        return e.v.engine.fuelEconomy
}</span>

/*
Tentará dar partida ao motor do veículo, as chances de sucesso dependerá
da quantidade de combustível armazenado no tanque e da carga da bateria

- Atualiza o endereço da várivael status para true, se o motor efetuar a
partida
*/
func (e *engineBuilder) Ignite(status *bool) *engineBuilder <span class="cov0" title="0">{
        lights := 0
        alarm := 0
        doors := 0
        bonnet := 0
        boot := 0
        objective := 0

        var ignite int
        if e.canIgniteEngine() </span><span class="cov0" title="0">{
                ignite = 1
        }</span>

        // e.v.Eletrics().IntroduceElectricalDrain()
        // time.Slieep(time.Duration(rand.Intn(30 - (3) + 30)))
        <span class="cov0" title="0">natives.SetVehicleParamsEx(
                e.v.id,
                ignite,
                lights,
                alarm,
                doors,
                bonnet,
                boot,
                objective,
        )
        return e</span>
}

func (e *engineBuilder) canIgniteEngine() bool <span class="cov8" title="1">{
        charger := e.v.Eletrics().GetBatteryCharger()
        fuel := e.GetFuel()

        rand.New(rand.NewSource(0))

        if fuel == 0 || charger == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">minConsumable := math.Min(float64(charger), float64(fuel))
        weight := rand.Intn(11) - 5

        failRange := rand.Intn(100) + 1
        successRange := int(minConsumable) + weight

        canIgnite := successRange &gt; failRange

        return canIgnite</span>
}

/*
Desliga o motor do veículo
*/
func (e *engineBuilder) TurnOff() *engineBuilder <span class="cov0" title="0">{
        lights := 0
        alarm := 0
        doors := 0
        bonnet := 0
        boot := 0
        objective := 0

        natives.GetVehicleParamsEx(
                e.v.id,
                nil,
                &amp;lights,
                &amp;alarm,
                &amp;doors,
                &amp;bonnet,
                &amp;boot,
                &amp;objective,
        )
        natives.SetVehicleParamsEx(
                e.v.id,
                0,
                lights,
                alarm,
                doors,
                bonnet,
                boot,
                objective,
        )
        return e
}</span>
</pre>
		
<<<<<<< HEAD
		<pre class="file" id="file13" style="display: none">package vehicles
=======
		<pre class="file" id="file15" style="display: none">package vehicles
>>>>>>> dev

import (
        "github.com/goseventh/rakstar/internal/natives"
        "github.com/goseventh/rakstar/player"
)

func (v *vehicleBuilder) Pos(x, y, z, rotate float32) *vehicleBuilder <span class="cov0" title="0">{
        v.posX, v.posY, v.posZ, v.rotate = x, y, z, rotate
        return v
}</span>

func (v *vehicleBuilder) Health(h float32) *vehicleBuilder <span class="cov0" title="0">{
        v.health = h
        return v
}</span>

func (v *vehicleBuilder) Color(prim, secon int) *vehicleBuilder <span class="cov0" title="0">{
        v.colorPrimary, v.colorSecondary = prim, secon
        return v
}</span>

/*
Escolhe o modelo do veículo para futuras criações
*/
func (v *vehicleBuilder) Model(m int) *vehicleBuilder <span class="cov0" title="0">{
        v.model = m
        return v
}</span>

/*
Cria o veículo e o spawna

seta o ID de criação do veículo após o spawn
*/
func (v *vehicleBuilder) Create() *vehicleBuilder <span class="cov0" title="0">{
        v.id = natives.CreateVehicle(
                v.model,
                v.posX,
                v.posY,
                v.posZ,
                v.rotate,
                v.colorPrimary,
                v.colorSecondary,
                -1,
                false,
        )
        return v
}</span>

// Adiciona um jogador a um assento disponível de um veículo
//
// a função tentará encontrar quais assentos estão disponíveis
// para o veiculo, caso houver setará automaticamente o jogador 
func (v *vehicleBuilder) AttachPlayer(p *player.PlayerBuilder) *vehicleBuilder<span class="cov0" title="0">{
        var seats[]int
        for i := 0; i &lt;= natives.GetMaxPlayers(); i++ </span><span class="cov0" title="0">{
                vehID := natives.GetPlayerVehicleID(i)
    if vehID != v.id</span><span class="cov0" title="0">{
      continue</span>
    }
    <span class="cov0" title="0">seat := natives.GetPlayerVehicleSeat(i)
    if seat &lt;= -1 </span><span class="cov0" title="0">{
      continue</span>
    }
    <span class="cov0" title="0">seats = append(seats, seat+1)</span>
        }
  
  <span class="cov0" title="0">if len(seats) &gt; 4 </span><span class="cov0" title="0">{
    v.AttachPlayer(p)
  }</span>

  <span class="cov0" title="0">for s := 0; s&lt;=4; s++</span><span class="cov0" title="0">{
    if seats[s] != 0</span><span class="cov0" title="0">{
      continue</span>
    }
    <span class="cov0" title="0">natives.PutPlayerInVehicle(p.ID, v.id, s-1)
    break</span>
  }
  <span class="cov0" title="0">return v</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
